{
  "language": "Solidity",
  "sources": {
    "MyXAuctionV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\";\n\n/**\n * @title MyXAuctionV2\n * @dev 拍卖合约（代理合约第一个版本），支持 ETH 和 ERC20 代币出价，使用 Chainlink 价格预言机统一价值比较\n *\n * 主要功能：\n * - 支持 ETH 和 ERC20 代币出价（通过 Chainlink 价格预言机统一价值比较）\n * - 拍卖手续费功能（可配置的手续费比例，支持动态手续费）\n * - 紧急暂停功能\n * - 批量获取拍卖信息的功能\n * - 拍卖统计信息和 TVL 追踪\n *\n * 注意：这是代理合约的第一个版本，使用 OpenZeppelin 可升级合约模式\n */\ncontract MyXAuctionV2 is Initializable, OwnableUpgradeable,ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20;\n\n    // 存储布局（重要：代理合约升级时不能改变现有变量的顺序和类型）\n    mapping(address => address) public priceFeeds;\n\n    struct Auction {\n        address nftAddress;\n        uint256 tokenId;\n        address seller;\n        address highestBidder;\n        address highestBidToken;\n        uint256 highestBid; //\n        uint256 highestBidValue;\n        uint256 startPrice; //美元价值x8因为chainlink价格是8位小数\n        uint256 startTime;\n        uint256 endTime;\n        bool ended;\n        bool cancelled;\n        uint256 bidCount;\n    }\n\n    Auction[] public auctions;\n\n    // 新增的存储变量（只能添加在现有变量之后）\n    uint256 public platformFee; // 平台手续费（基点，100 = 1%），用于向后兼容\n    bool public paused; // 紧急暂停标志\n    uint256 public totalAuctionsCreated; // 总创建的拍卖数\n    uint256 public totalBidsPlaced; // 总出价次数\n    mapping(uint256 => uint256) public auctionBidCount; // 每个拍卖的出价次数\n    uint256 public totalValueLocked; // 总锁定价值（TVL，USD 价值，8位小数）\n\n    // 动态手续费配置（基于 USD 价值）\n    struct FeeTier {\n        uint256 threshold; // 阈值（USD 价值，8位小数）\n        uint256 feeRate; // 手续费率（基点，100 = 1%）\n    }\n    FeeTier[] public feeTiers; // 手续费档次数组，按阈值从低到高排序\n    bool public useDynamicFee; // 是否使用动态手续费\n    uint256 public baseFeeRate; // 基础费率（用于低于最低阈值的金额）\n    mapping(address => uint256[]) public userCreatedAuctionIds; // 用户创建的拍卖ID列表\n    uint256 private constant TIME_BUFFER = 60;\n    // ============ 事件声明 ============\n    //出价事件成功后触发\n    event BidPlaced(\n        uint256 indexed auctionId,\n        address indexed bidder, //当前出价者地址\n        uint256 amount, //支付代币最小单位数量\n        address indexed paymentToken, //支付代币地址\n        uint256 bidCount, //出价次数\n        uint256 timestamp, //出价时间戳\n        uint256 bidValue, //出价金额(美元价值x8)\n        address minBidder, //上一个高出价者\n        uint256 minBidValue //上一个高出价者的平台出价值(美元价值x8)\n    );\n    //出价金额低于最低出价金额事件\n    event BidValueTooLow(\n        uint256 indexed auctionId,\n        address indexed bidder, //当前出价者地址\n        uint256 amount, //支付代币最小单位数量\n        address indexed paymentToken, //支付代币地址\n        uint256 bidCount, //出价次数\n        uint256 timestamp, //出价时间戳\n        uint256 bidValue, //当前出价金额(美元价值x8)\n        address minBidder, //上一个高出价者地址\n        uint256 minBidValue //上一个高出价者的平台出价值(美元价值x8)\n    );\n    event AuctionEnded(\n        uint256 indexed auctionId,\n        address indexed winner,\n        uint256 finalBid,\n        address seller,\n        address paymentToken,\n        uint256 bidValue,\n        uint256 minBidValue\n    );\n    event PlatformFeeUpdated(uint256 oldFee, uint256 newFee);\n    event FeeTierUpdated(\n        uint256 indexed tierIndex,\n        uint256 threshold,\n        uint256 feeRate\n    ); // 动态手续费档次更新事件\n    event DynamicFeeEnabled(bool enabled); // 动态手续费启用/禁用事件\n    event Paused(address account);\n    event Unpaused(address account);\n    event AuctionForceEnded(uint256 indexed auctionId, address indexed endedBy); // 强制结束事件\n    event AuctionCreated(\n        uint256 indexed auctionId,\n        address indexed creator,\n        address indexed nftAddress,\n        uint256 tokenId\n    ); // 拍卖创建事件\n    event TotalValueLockedUpdated(\n        uint256 newTVL,\n        uint256 totalBidsPlaced,\n        uint256 change,\n        bool isIncrease\n    ); // TVL更新事件\n    event AuctionCancelled(\n        uint256 indexed auctionId,\n        address indexed cancelledBy,\n        address bidder,\n        address indexed paymentToken,\n        uint256 refundAmount,\n        uint256 refundAmountValue\n    ); // 拍卖取消事件\n    event NFTApproved(\n        address indexed owner,\n        address indexed nftAddress,\n        uint256 tokenId\n    ); // NFT批准事件\n    event NFTApprovalCancelled(\n        address indexed owner,\n        address indexed nftAddress,\n        uint256 tokenId\n    ); // NFT取消批准事件\n    // ============ 构造函数和初始化函数 ============\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev 初始化函数（代理合约的第一个版本）\n     * 注意：这个函数不会重新初始化，只是设置 V2 的新变量\n     */\n    function initialize() public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        platformFee = 0; // 默认无手续费\n        paused = false;\n        totalAuctionsCreated = 0;\n        totalBidsPlaced = 0;\n        totalValueLocked = 0; // 初始化 TVL\n        useDynamicFee = false; // 默认使用固定手续费\n        baseFeeRate = 0; // 默认基础费率为 0\n    }\n    /**\n     * @dev V2 初始化函数（用于升级时调用）\n     * 注意：这个函数不会重新初始化，只是设置 V2 的新变量\n     * @custom:oz-upgrades-validate-as-initializer\n     */\n    function initializeV2() public reinitializer(2) {\n        __Ownable_init(owner());\n        __ReentrancyGuard_init();\n    }\n\n    /**\n     * @dev 设置平台手续费（基点，100 = 1%）\n     * @param _fee 手续费基点（最大 1000 = 10%）\n     * 注意：如果启用了动态手续费，此函数设置的固定手续费将被忽略\n     */\n    function setPlatformFee(uint256 _fee) public onlyOwner {\n        require(_fee <= 1000, \"Fee cannot exceed 10%\");\n        uint256 oldFee = platformFee;\n        platformFee = _fee;\n        emit PlatformFeeUpdated(oldFee, _fee);\n    }\n\n    /**\n     * @dev 设置动态手续费档次\n     * @param _thresholds 阈值数组（USD 价值，8位小数，按从低到高排序）\n     * @param _feeRates 手续费率数组（基点，100 = 1%，对应每个阈值）\n     * 示例：thresholds = [1000e8, 10000e8, 100000e8] (对应 $1000, $10000, $100000)\n     *       feeRates = [500, 300, 100] (对应 5%, 3%, 1%)\n     * 表示：$0-$1000: 5%, $1000-$10000: 3%, $10000-$100000: 1%, $100000+: 1%\n     */\n    function setFeeTiers(\n        uint256[] memory _thresholds,\n        uint256[] memory _feeRates\n    ) public onlyOwner {\n        require(\n            _feeRates.length == _thresholds.length + 1,\n            \"Fee rates array must have one more element than thresholds\"\n        );\n        require(_thresholds.length > 0, \"At least one tier required\");\n        require(_thresholds.length <= 10, \"Too many tiers (max 10)\");\n\n        // 清空现有档次\n        delete feeTiers;\n\n        // 存储基础费率（用于低于最低阈值的金额）\n        require(_feeRates[0] <= 1000, \"Fee rate cannot exceed 10%\");\n        baseFeeRate = _feeRates[0];\n\n        // 验证并添加档次\n        uint256 lastThreshold = 0;\n        for (uint256 i = 0; i < _thresholds.length; i++) {\n            require(\n                _thresholds[i] > lastThreshold,\n                \"Thresholds must be in ascending order\"\n            );\n            require(_feeRates[i + 1] <= 1000, \"Fee rate cannot exceed 10%\");\n\n            feeTiers.push(\n                FeeTier({\n                    threshold: _thresholds[i],\n                    feeRate: _feeRates[i + 1] // 使用 i+1 索引，因为 feeRates[0] 已存储在 baseFeeRate\n                })\n            );\n\n            emit FeeTierUpdated(i, _thresholds[i], _feeRates[i + 1]);\n            lastThreshold = _thresholds[i];\n        }\n\n        // 启用动态手续费\n        useDynamicFee = true;\n        emit DynamicFeeEnabled(true);\n    }\n\n    /**\n     * @dev 启用或禁用动态手续费\n     * @param _enabled true 启用动态手续费，false 使用固定手续费\n     */\n    function setDynamicFeeEnabled(bool _enabled) public onlyOwner {\n        require(\n            _enabled == false || feeTiers.length > 0,\n            \"Must set fee tiers before enabling\"\n        );\n        useDynamicFee = _enabled;\n        emit DynamicFeeEnabled(_enabled);\n    }\n\n    /**\n     * @dev 根据 USD 价值计算动态手续费\n     * @param _usdValue 拍卖金额的 USD 价值（8位小数）\n     * @return feeRate 手续费率（基点）\n     *\n     * 逻辑说明：\n     * - 每个阈值对应一个费率，该费率用于该阈值及以上但小于下一个阈值的金额\n     * - 最后一个费率用于最高阈值及以上的所有金额\n     * - 如果金额低于最低阈值，使用第一个费率\n     */\n    function calculateDynamicFeeRate(\n        uint256 _usdValue\n    ) public view returns (uint256 feeRate) {\n        if (!useDynamicFee || feeTiers.length == 0) {\n            return platformFee; // 如果未启用动态手续费，返回固定手续费\n        }\n\n        // 从最高档次开始查找（因为数组是按阈值从低到高排序的）\n        // 找到第一个金额 >= 阈值的档次\n        for (uint256 i = feeTiers.length; i > 0; i--) {\n            if (_usdValue >= feeTiers[i - 1].threshold) {\n                // 返回该阈值对应的费率\n                // 注意：这个费率用于该阈值及以上但小于下一个阈值的金额\n                return feeTiers[i - 1].feeRate;\n            }\n        }\n\n        // 如果金额低于最低阈值，使用基础费率\n        return baseFeeRate;\n    }\n\n    /**\n     * @dev 获取手续费档次数量\n     */\n    function getFeeTierCount() public view returns (uint256) {\n        return feeTiers.length;\n    }\n\n    /**\n     * @dev 获取所有手续费档次\n     */\n    function getAllFeeTiers() public view returns (FeeTier[] memory) {\n        return feeTiers;\n    }\n\n    /**\n     * @dev 紧急暂停所有操作\n     */\n    function pause() public onlyOwner {\n        require(!paused, \"Already paused\");\n        paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @dev 取消暂停\n     */\n    function unpause() public onlyOwner {\n        require(paused, \"Not paused\");\n        paused = false;\n        emit Unpaused(msg.sender);\n    }\n\n    /**\n     * @dev 修改器：检查是否暂停\n     */\n    modifier whenNotPaused() {\n        require(!paused, \"Contract is paused\");\n        _;\n    }\n\n    // ============ 核心功能函数 ============\n\n    function setPriceFeed(address _token, address _priceFeed) public onlyOwner {\n        require(_priceFeed != address(0), \"Invalid price feed address\");\n        priceFeeds[_token] = _priceFeed;\n    }\n\n    function setPriceFeeds(\n        address[] memory _tokens,\n        address[] memory _priceFeeds\n    ) public onlyOwner {\n        require(_tokens.length == _priceFeeds.length, \"Arrays length mismatch\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            require(_priceFeeds[i] != address(0), \"Invalid price feed address\");\n            priceFeeds[_tokens[i]] = _priceFeeds[i];\n        }\n    }\n\n    function getTokenPrice(\n        address _token\n    ) public view returns (uint256 price, uint8 decimals) {\n        address priceFeed = priceFeeds[_token];\n        require(priceFeed != address(0), \"Price feed not set for this token\");\n\n        AggregatorV3Interface oracle = AggregatorV3Interface(priceFeed);\n        (, int256 priceInt, , , ) = oracle.latestRoundData();\n        require(priceInt > 0, \"Invalid price from oracle\");\n\n        decimals = oracle.decimals();\n        price = uint256(priceInt);\n    }\n\n    function convertToUSDValue(\n        address _token,\n        uint256 _amount\n    ) public view returns (uint256) {\n        (uint256 price, ) = getTokenPrice(_token);\n\n        // 获取代币精度\n        uint8 tokenDecimals;\n        if (_token == address(0)) {\n            // ETH 是 18 位小数\n            tokenDecimals = 18;\n        } else {\n            // ERC20 代币，尝试获取 decimals（如果失败则假设 18）\n            try IERC20Metadata(_token).decimals() returns (uint8 dec) {\n                tokenDecimals = dec; //ERC20代币精度\n            } catch {\n                tokenDecimals = 18; // 默认ETH是18位小数\n            }\n        }\n\n        // 计算美元价值\n        // Chainlink 价格是 8 位小数\n        // 公式：usdValue = (amount * price) / (10^tokenDecimals)\n        // 结果已经是 8 位小数（因为 price 是 8 位小数）\n\n        return (_amount * price) / (10 ** uint256(tokenDecimals));\n    }\n\n    function approveNFT(\n        address _nftAddress,\n        uint256 _tokenId\n    ) public whenNotPaused {\n        // 批准NFT给合约\n        // IERC721 nft = IERC721(_nftAddress);\n        // require(nft.ownerOf(_tokenId) == msg.sender, \"You must own the NFT\");\n        // nft.approve(address(this), _tokenId);\n        // emit NFTApproved(msg.sender, _nftAddress, _tokenId);\n    }\n\n    function cancelNFTApproval(\n        address _nftAddress,\n        uint256 _tokenId\n    ) public whenNotPaused {\n        // 取消NFT的批准\n        // IERC721 nft = IERC721(_nftAddress);\n        // require(nft.ownerOf(_tokenId) == msg.sender, \"You must own the NFT\");\n        // nft.approve(address(0), _tokenId);\n        // emit NFTApprovalCancelled(msg.sender, _nftAddress, _tokenId);\n    }\n\n    function createAuction(\n        address _nftAddress,\n        uint256 _tokenId,\n        uint256 _startPrice, //设成美元的chainlink价格x8\n        uint256 _startTime,\n        uint256 _endTime\n    ) public whenNotPaused returns (uint256) {\n        //NFT is owned by the user\n        require(_startTime < _endTime, \"Start time must be before end time\");\n        require(_startPrice > 0, \"Start price must be greater than 0\");\n\n        IERC721 nft = IERC721(_nftAddress);\n        require(nft.ownerOf(_tokenId) == msg.sender, \"You must own the NFT\");\n        nft.transferFrom(msg.sender, address(this), _tokenId);\n        auctions.push(\n            Auction({\n                nftAddress: _nftAddress,\n                tokenId: _tokenId,\n                seller: msg.sender,\n                highestBidder: address(0),\n                highestBidToken: address(0),\n                highestBid: 0,\n                highestBidValue: 0,\n                startPrice: _startPrice, //美元价值x8因为chainlink价格是8位小数\n                startTime: _startTime,\n                endTime: _endTime,\n                ended: false,\n                cancelled: false,\n                bidCount: 0\n            })\n        );\n        uint256 auctionId = auctions.length - 1;\n        totalAuctionsCreated++;\n\n        // 注意：创建拍卖时不将起拍价加入TVL，只有实际出价后才计入\n\n        uint256[] storage userAuctionIds = userCreatedAuctionIds[msg.sender];\n        userAuctionIds.push(auctionId);\n        emit AuctionCreated(auctionId, msg.sender, _nftAddress, _tokenId);\n        return auctionId;\n    }\n\n    function getUserCreatedAuctions(\n        address _user\n    ) public view returns (Auction[] memory) {\n        uint256[] storage userAuctionIds = userCreatedAuctionIds[_user];\n        uint256 length = userAuctionIds.length;\n        Auction[] memory result = new Auction[](length);\n        for (uint256 i = 0; i < length; i++) {\n            result[i] = auctions[userAuctionIds[i]];\n        }\n        return result;\n    }\n\n    function bid(\n        uint256 _auctionId,\n        uint256 _amount, // ETH/USDC *10^decimals 是精度值 合约里面代币都是最小单位表示\n        address _token\n    ) public payable whenNotPaused nonReentrant {\n        require(_amount > 0, \"Bid amount must be greater than 0\");\n        if (_token == address(0)) {\n            //ETH转账必须与bid amount一致\n            require(msg.value == _amount, \"ETH amount must match bid amount\");\n        }\n        require(_auctionId < auctions.length, \"Auction does not exist\");\n        Auction storage auction = auctions[_auctionId];\n        require(\n            !auction.ended && !auction.cancelled,\n            \"Auction has ended or cancelled\"\n        );\n        require(\n            block.timestamp >= auction.startTime &&\n                block.timestamp <= auction.endTime,\n            \"Auction has not started or ended \"\n        );\n        require(\n            priceFeeds[_token] != address(0),\n            \"Price feed not set for this token\"\n        );\n\n        uint256 bidValue = convertToUSDValue(_token, _amount);\n\n        uint256 minBidValue = auction.highestBidValue == 0\n            ? auction.startPrice //这个是美元价格x8因为chainlink价格是8位小数\n            : auction.highestBidValue;\n\n        uint256 bidCount = auctionBidCount[_auctionId]; //获取当前拍卖的出价次数\n        bidCount++;\n        auctionBidCount[_auctionId] = bidCount;\n        auction.bidCount = bidCount;\n\n        // 记录出价次数\n        totalBidsPlaced++;\n\n        if (bidValue < minBidValue) {\n            emit BidValueTooLow(\n                _auctionId,\n                msg.sender,\n                _amount,\n                _token,\n                bidCount,\n                block.timestamp,\n                bidValue,\n                auction.highestBidder,\n                auction.highestBidValue\n            );\n            revert(\"Bid value must be greater than the minimum required value\");\n        }\n\n        if (_token != address(0)) {\n            //ERC20\n            require(msg.value == 0, \"Cannot send ETH for ERC20 bid\");\n            IERC20 token = IERC20(_token);\n            require(\n                token.allowance(msg.sender, address(this)) >= _amount,\n                \"Insufficient token allowance\"\n            );\n            require(\n                token.balanceOf(msg.sender) >= _amount,\n                \"Insufficient token balance\"\n            );\n\n            token.safeTransferFrom(msg.sender, address(this), _amount);\n        }\n\n        // 保存旧出价者信息（在更新状态前）\n        address previousBidder = auction.highestBidder;\n        address previousBidToken = auction.highestBidToken;\n        uint256 previousBid = auction.highestBid;\n        uint256 previousBidValue = auction.highestBidValue;\n\n        // 更新拍卖状态（在退还前，确保状态一致性）\n        auction.highestBidder = msg.sender;\n        auction.highestBidToken = _token;\n        auction.highestBid = _amount;\n        auction.highestBidValue = bidValue;\n\n        // 退还前一个出价者（使用保存的旧值）\n        if (previousBidder != address(0)) {\n            if (previousBidToken == address(0)) {\n                (bool success, ) = payable(previousBidder).call{\n                    value: previousBid\n                }(\"\");\n                require(success, \"Failed to refund previous bidder\");\n            } else {\n                IERC20 token = IERC20(previousBidToken);\n                token.safeTransfer(previousBidder, previousBid);\n            }\n        }\n\n        // 更新 TVL：只有实际出价后才计入TVL（使用保存的旧值）\n        uint256 oldTVL = totalValueLocked;\n        if (previousBidValue > 0) {\n            // 已有出价：更新TVL（从旧出价更新为新出价）\n            totalValueLocked = totalValueLocked - previousBidValue + bidValue;\n        } else {\n            // 第一次出价：将出价价值加入TVL\n            totalValueLocked += bidValue;\n        }\n\n        emit BidPlaced(\n            _auctionId,\n            msg.sender,\n            _amount,\n            _token,\n            bidCount,\n            block.timestamp,\n            bidValue,\n            previousBidder,\n            previousBidValue\n        );\n        // 发出TVL更新事件\n        uint256 change = totalValueLocked > oldTVL\n            ? totalValueLocked - oldTVL\n            : oldTVL - totalValueLocked;\n        emit TotalValueLockedUpdated(\n            totalValueLocked,\n            totalBidsPlaced,\n            change,\n            totalValueLocked > oldTVL\n        );\n    }\n\n    /**\n     * @dev 内部函数：执行拍卖结束的通用逻辑（转移 NFT 和资金）\n     * @param _auctionId 拍卖 ID\n     * @param auction 拍卖存储引用\n     */\n    function _endAuctionInternal(\n        uint256 _auctionId,\n        Auction storage auction\n    ) internal {\n        IERC721 nft = IERC721(auction.nftAddress);\n\n        // 更新 TVL：移除该拍卖的锁定价值（只有实际出价后才需要移除）\n        if (auction.highestBidValue > 0) {\n            totalValueLocked -= auction.highestBidValue;\n            // 发出TVL更新事件\n            emit TotalValueLockedUpdated(\n                totalValueLocked,\n                totalBidsPlaced,\n                auction.highestBidValue,\n                false\n            );\n        }\n\n        if (auction.highestBidder != address(0)) {\n            nft.transferFrom(\n                address(this),\n                auction.highestBidder,\n                auction.tokenId\n            );\n\n            // 计算并扣除手续费（支持动态手续费）\n            uint256 feeAmount = 0;\n            uint256 sellerAmount = auction.highestBid;\n\n            // 根据是否启用动态手续费选择计算方式\n            uint256 effectiveFeeRate;\n            if (useDynamicFee && feeTiers.length > 0) {\n                // 使用动态手续费：根据 USD 价值计算手续费率\n                effectiveFeeRate = calculateDynamicFeeRate(\n                    auction.highestBidValue\n                );\n            } else {\n                // 使用固定手续费\n                effectiveFeeRate = platformFee;\n            }\n\n            if (effectiveFeeRate > 0) {\n                feeAmount = (auction.highestBid * effectiveFeeRate) / 10000;\n                sellerAmount = auction.highestBid - feeAmount;\n            }\n\n            if (auction.highestBidToken == address(0)) {\n                // 转移 ETH 给卖家（扣除手续费）\n                (bool success1, ) = payable(auction.seller).call{\n                    value: sellerAmount\n                }(\"\");\n                require(success1, \"Failed to transfer funds to seller\");\n\n                // 如果有手续费，转移给合约所有者\n                if (feeAmount > 0) {\n                    (bool success2, ) = payable(owner()).call{value: feeAmount}(\n                        \"\"\n                    );\n                    require(success2, \"Failed to transfer fee to owner\");\n                }\n            } else {\n                IERC20 token = IERC20(auction.highestBidToken);\n                // 转移代币给卖家（扣除手续费）\n                token.safeTransfer(auction.seller, sellerAmount);\n\n                // 如果有手续费，转移给合约所有者\n                if (feeAmount > 0) {\n                    token.safeTransfer(owner(), feeAmount);\n                }\n            }\n\n            emit AuctionEnded(\n                _auctionId,\n                auction.highestBidder,\n                auction.highestBid,\n                auction.seller,\n                auction.highestBidToken,\n                auction.highestBidValue,\n                auction.startPrice\n            );\n        } else {\n            nft.transferFrom(address(this), auction.seller, auction.tokenId);\n            emit AuctionEnded(\n                _auctionId,\n                address(0),\n                0,\n                auction.seller,\n                address(0),\n                0,\n                0\n            );\n        }\n    }\n\n    /**\n     * @dev 结束拍卖并领取 NFT\n     * @param _auctionId 拍卖 ID\n     */\n    function endAuctionAndClaimNFT(\n        uint256 _auctionId\n    ) public onlyOwner whenNotPaused {\n        require(_auctionId < auctions.length, \"Auction does not exist\");\n        Auction storage auction = auctions[_auctionId];\n        require(\n            !auction.ended && !auction.cancelled,\n            \"Auction has already ended or cancelled\"\n        );\n        require(\n            //60秒的缓冲时间\n            block.timestamp >= auction.endTime - TIME_BUFFER,\n            \"Auction has not ended yet\"\n        );\n\n        auction.ended = true;\n        _endAuctionInternal(_auctionId, auction);\n    }\n\n    /**\n     * @dev 强制结束拍卖并领取 NFT\n     * @param _auctionId 拍卖 ID\n     * 强制结束会：\n     * 1. 修改拍卖结束时间为当前时间\n     * 2. 将拍卖状态标记为已结束\n     * 3. 执行正常的结束流程（转移 NFT 和资金）\n     */\n    function forceEndAuctionAndClaimNFT(\n        uint256 _auctionId\n    ) public onlyOwner whenNotPaused {\n        require(_auctionId < auctions.length, \"Auction does not exist\");\n\n        Auction storage auction = auctions[_auctionId];\n        require(\n            !auction.ended && !auction.cancelled,\n            \"Auction has already ended or cancelled\"\n        );\n\n        // 强制结束：修改结束时间为当前时间并标记为已结束\n        auction.endTime = block.timestamp;\n        auction.ended = true;\n        _endAuctionInternal(_auctionId, auction);\n        emit AuctionForceEnded(_auctionId, msg.sender);\n    }\n\n    /**\n     * @dev 关闭拍卖并退还NFT和拍卖金额\n     * @param _auctionId 拍卖 ID\n     * 功能：\n     * - 只能由卖家或合约所有者调用\n     * - 将NFT退还给卖家\n     * - 如果有出价，将出价金额全额退还给最高出价者（不扣除手续费）\n     * - 更新TVL（如果有出价，从TVL中移除）\n     * - 发出取消事件\n     */\n    function cancelAuction(uint256 _auctionId) public onlyOwner whenNotPaused nonReentrant {\n        require(_auctionId < auctions.length, \"Auction does not exist\");\n\n        Auction storage auction = auctions[_auctionId];\n        require(\n            !auction.ended && !auction.cancelled,\n            \"Auction has already ended or cancelled\"\n        );\n        require(\n            msg.sender == auction.seller || msg.sender == owner(),\n            \"Only seller or owner can cancel auction\"\n        );\n\n        // 标记拍卖为已结束\n        auction.ended = true;\n        // 标记拍卖为已取消\n        auction.cancelled = true;\n\n        IERC721 nft = IERC721(auction.nftAddress);\n\n        // 更新 TVL：移除该拍卖的锁定价值（只有实际出价后才需要移除）\n        if (auction.highestBidValue > 0) {\n            totalValueLocked -= auction.highestBidValue;\n            // 发出TVL更新事件\n            emit TotalValueLockedUpdated(\n                totalValueLocked,\n                totalBidsPlaced,\n                auction.highestBidValue,\n                false\n            );\n        }\n\n        // 将NFT退还给卖家\n        nft.transferFrom(address(this), auction.seller, auction.tokenId);\n\n        // 如果有出价，将出价金额全额退还给最高出价者\n        if (auction.highestBidder != address(0)) {\n            if (auction.highestBidToken == address(0)) {\n                // 退还 ETH\n                (bool success, ) = payable(auction.highestBidder).call{\n                    value: auction.highestBid\n                }(\"\");\n                require(success, \"Failed to refund bidder\");\n            } else {\n                // 退还 ERC20 代币\n                IERC20 token = IERC20(auction.highestBidToken);\n                token.safeTransfer(auction.highestBidder, auction.highestBid);\n            }\n        }\n\n        // 发出取消事件\n        emit AuctionCancelled(\n            _auctionId,\n            msg.sender,\n            auction.highestBidder,\n            auction.highestBidToken,\n            auction.highestBid,\n            auction.highestBidValue\n        );\n    }\n    \n    /**\n    * @dev 取消用户拍卖\n    * @param _auctionId 拍卖 ID\n    * 功能：\n    * - 只能由卖家调用\n    * - 拍卖必须没有出价，否则无法取消\n    * - 拍卖必须没有结束，否则无法取消\n    * - 拍卖必须没有取消，否则无法取消\n    * - 拍卖必须没有结束，否则无法取消\n    */\n    function cancelUserAuction(uint256  _auctionId) public whenNotPaused nonReentrant returns (bool) {\n        require(_auctionId < auctions.length, \"Auction does not exist\");\n        Auction storage auction = auctions[_auctionId];\n        require(\n            msg.sender == auction.seller,\n            \"Only seller can cancel auction\"); //只能卖家取消\n        require(\n            !auction.ended && !auction.cancelled,\n            \"Auction has already ended or cancelled\"\n        );//必须没有结束或取消，否则无法取消\n        require(auction.highestBidder==address(0), \"Auction has bids, cannot cancel\");//必须没有出价，否则无法取消\n        require(auction.highestBidToken == address(0), \"Auction has token bids, cannot cancel\");//必须没有代币出价，否则无法取消\n        auction.cancelled = true;\n        auction.ended = true;\n        IERC721 nft = IERC721(auction.nftAddress);\n        nft.transferFrom(address(this), auction.seller, auction.tokenId);\n        emit AuctionCancelled(_auctionId, msg.sender, address(0), address(0), 0, 0);\n        return true;\n    }\n    function getAuction(\n        uint256 _auctionId\n    ) public view returns (Auction memory) {\n        return auctions[_auctionId];\n    }\n\n    function getAuctionCount() public view returns (uint256) {\n        return auctions.length;\n    }\n\n    // ============ 扩展功能 ============\n\n    /**\n     * @dev 批量获取拍卖信息\n     * @param _startIndex 起始索引\n     * @param _count 获取数量\n     */\n    function getAuctionsBatch(\n        uint256 _startIndex,\n        uint256 _count\n    ) public view returns (Auction[] memory) {\n        require(_startIndex < auctions.length, \"Start index out of bounds\");\n\n        uint256 endIndex = _startIndex + _count;\n        if (endIndex > auctions.length) {\n            endIndex = auctions.length;\n        }\n\n        uint256 resultCount = endIndex - _startIndex;\n        Auction[] memory result = new Auction[](resultCount);\n\n        for (uint256 i = 0; i < resultCount; i++) {\n            result[i] = auctions[_startIndex + i];\n        }\n\n        return result;\n    }\n    function getAuctionSimpleStats()\n        external\n        view\n        returns (\n            uint256 ,\n            uint256 ,\n            uint256 ,\n            uint256 \n        )\n    {\n        return (totalAuctionsCreated, totalBidsPlaced, platformFee, totalValueLocked);\n    }\n    /**\n     * @dev 获取拍卖统计信息\n     */\n    function getAuctionStats()\n        public\n        view\n        returns (\n            uint256 totalAuctions,\n            uint256 totalBids,\n            uint256 currentPlatformFee,\n            bool isPaused,\n            uint256 activeAuctions\n        )\n    {\n        totalAuctions = totalAuctionsCreated;\n        totalBids = totalBidsPlaced;\n        currentPlatformFee = platformFee;\n        isPaused = paused;\n\n        // 计算活跃拍卖数\n        uint256 active = 0;\n        uint256 currentTime = block.timestamp;\n        for (uint256 i = 0; i < auctions.length; i++) {\n            if (\n                !auctions[i].ended &&\n                currentTime >= auctions[i].startTime &&\n                currentTime <= auctions[i].endTime\n            ) {\n                active++;\n            }\n        }\n        activeAuctions = active;\n    }\n\n    /**\n     * @dev 获取用户创建的拍卖数量\n     * @param _user 用户地址\n     * @return 用户创建的拍卖数量\n     */\n    function getUserCreatedAuctionCount(\n        address _user\n    ) public view returns (uint256) {\n        uint256[] storage userAuctionIds = userCreatedAuctionIds[_user];\n        return userAuctionIds.length;\n    }\n\n    /**\n     * @dev 获取总锁定价值（TVL - Total Value Locked）\n     * @return tvl 总锁定价值（USD 价值，8位小数）\n     *\n     * TVL 通过状态变量实时维护，gas 消耗极低（仅读取一个存储变量）\n     * - 创建拍卖时不计入TVL（起拍价不是实际锁定资金）\n     * - 第一次出价时将出价价值加入TVL\n     * - 后续出价时更新TVL（从旧出价更新为新出价）\n     * - 结束拍卖时移除锁定价值（只有有出价的拍卖才需要移除）\n     */\n    function getTotalValueLocked() public view returns (uint256) {\n        return totalValueLocked;\n    }\n\n    function version() public pure returns (string memory) {\n        return \"2.0.0\";\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode"
        ]
      }
    }
  }
}